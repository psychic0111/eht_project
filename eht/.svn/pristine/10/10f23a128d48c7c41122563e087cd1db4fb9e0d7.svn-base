package com.eht.webservice.service.util;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;

import org.apache.log4j.Logger;

import com.eht.common.bean.ResponseStatus;
import com.eht.common.cache.DataCacheTool;
import com.eht.common.constant.Constants;
import com.eht.common.constant.ResponseCode;
import com.eht.common.constant.SynchConstants;
import com.eht.common.util.AppContextUtils;
import com.eht.common.util.FileToolkit;
import com.eht.common.util.JsonUtil;
import com.eht.log.entity.SynchLogEntity;
import com.eht.log.service.SynchLogServiceI;
import com.eht.note.entity.AttachmentEntity;

public class DataSynchizeUtil {
	
	private static Logger logger = Logger.getLogger(DataSynchizeUtil.class);
	
	public static ResponseStatus copyServerFile(AttachmentEntity attaServer, AttachmentEntity attachment){
		ResponseStatus res = new ResponseStatus(); //上传文件操作结果
		try {
			FileToolkit.copyFile(attaServer.getFilePath() + File.separator + attaServer.getFileName(), attachment.getFilePath());
		} catch (IOException e) {
			logger.error("服务器复制文件失败！！！");
			e.printStackTrace();
			res = new ResponseStatus(ResponseCode.SERVER_ERROR);
			e.printStackTrace();
			return res;
		}
		if(!attaServer.getFileName().equals(attachment.getFileName())){
			FileToolkit.renameFile(attachment.getFilePath() + File.separator + attaServer.getFileName(), attachment.getFilePath() + attachment.getFileName());
		}
		
		attachment.setStatus(Constants.FILE_TRANS_COMPLETED);
		attachment.setTranSfer(attaServer.getTranSfer());
		
		return res;
	}
	
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static Map<String, Object> parseLog(SynchLogEntity log){
		Serializable data = null;
		Map<String, Object> map = new HashMap<String, Object>();
		SynchLogServiceI synchLogService = AppContextUtils.getBean("synchLogService");
		if (!log.getAction().equals(SynchConstants.DATA_OPERATE_DELETE) && !log.getClassName().equals(SynchConstants.DATA_CLASS_DIRECTORYBLACK) && !log.getClassName().equals(SynchConstants.DATA_CLASS_NOTEBLACK)
				&& !log.getClassName().equals(SynchConstants.DATA_CLASS_SUBJECTUSER)) {
			Class c = DataCacheTool.getDataClass(log.getClassName());
			data = synchLogService.getEntity(c, log.getClassPK());
			String dataJson = JsonUtil.bean2json(data);
			map = JsonUtil.getMap4Json(dataJson);
		}
		
		map.put("operation", log.getAction());
		map.put("className", log.getClassName());
		map.put("classPK", log.getClassPK());
		map.put("operateTime", log.getOperateTime());
		
		return map;
	}
}
