package com.eht.log.service.impl;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.log4j.Logger;
import org.hibernate.criterion.DetachedCriteria;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.jeecgframework.core.common.service.impl.CommonServiceImpl;
import org.jeecgframework.core.util.ContextHolderUtils;
import org.jeecgframework.core.util.StringUtil;
import org.jeecgframework.core.util.oConvertUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.eht.common.bean.ResponseStatus;
import com.eht.common.constant.SynchConstants;
import com.eht.group.entity.Group;
import com.eht.group.service.GroupService;
import com.eht.log.entity.SynchLogEntity;
import com.eht.log.entity.SynchronizedLogEntity;
import com.eht.log.service.SynchLogServiceI;
import com.eht.note.service.AttachmentServiceI;
import com.eht.note.service.NoteServiceI;
import com.eht.subject.entity.SubjectEntity;
import com.eht.subject.service.DirectoryServiceI;
import com.eht.subject.service.SubjectServiceI;
import com.eht.system.bean.ClientEntity;
import com.eht.system.service.DataInitService;
import com.eht.user.entity.AccountEntity;
import com.eht.user.service.AccountServiceI;
import com.eht.webservice.service.impl.DataSynchizeServiceImpl;

@Service("synchLogService")
@Transactional
public class SynchLogServiceImpl extends CommonServiceImpl implements SynchLogServiceI {
	
	private Logger logger = Logger.getLogger(DataSynchizeServiceImpl.class);
	
	@Autowired
	private DataInitService dataInitService;
	
	@Autowired
	private SubjectServiceI subjectService;
	
	@Autowired
	private DirectoryServiceI directoryService;
	
	@Autowired
	private NoteServiceI noteService;
	
	@Autowired
	private AccountServiceI accountService;
	
	@Autowired
	private AttachmentServiceI attachmentService;
	
	@Autowired
	private GroupService groupService;
	
	@Override
	public SynchLogEntity getSynchLog(String logId) {
		return get(SynchLogEntity.class, logId);
	}

	@Override
	public String saveSynchLog(SynchLogEntity log) {
		logger.info("保存操作日志; 数据类型：" + log.getClassName() + ", 数据主键：" + log.getClassPK() + ", 数据操作：" + log.getAction());
		ClientEntity client = null;
		SecurityContext securityContext = SecurityContextHolder.getContext(); 
		if(securityContext != null){
			AccountEntity user = accountService.getUser4Session();
			if(user == null){
				//String sessionId = ContextHolderUtils.getRequest().getParameter("jsessionid");
				String sessionId = ContextHolderUtils.getRequest().getAttribute("jsessionid").toString();
				user = accountService.getUser4Session(sessionId);
			}
			String clientId = user.getClientId();
			if(!StringUtil.isEmpty(clientId)){
				client = dataInitService.getClient(clientId);
			}
		}
		if(client != null){
			log.setClientId(client.getClientId());
			log.setClientType(client.getClientType());
		}else{
			// 默认为WEB客户端
			log.setClientId(SynchConstants.CLIENT_DEFAULT_ID);
			log.setClientType(SynchConstants.CLIENT_DEFAULT_TYPE);
		}
		
		SynchLogEntity oldLog = findLogByData(log.getClassName(), log.getClassPK(), log.getTargetUser(), log.getAction());
		if(oldLog != null){
			logger.info("发现已存在日志; 数据类型：" + oldLog.getClassName() + ", 数据主键：" + oldLog.getClassPK() + ", 数据操作：" + oldLog.getAction());
			if(oldLog.getOperateTime() > log.getOperateTime()){
				logger.info("已有数据操作时间比此次操作日志时间新, 忽略此次日志记录!");
			}else{
				oldLog.setOperateUser(log.getOperateUser());
				oldLog.setOperateTime(log.getOperateTime());
				oldLog.setSynchTime(System.currentTimeMillis());
				oldLog.setClientType(log.getClientType());
				oldLog.setClientId(log.getClientId());
				updateEntitie(oldLog);
			}
		}else{
			save(log);
		}
		return new ResponseStatus().toString();
	}

	@Override
	public List<SynchLogEntity> findLogByData(String dataClass, String dataKey) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.eq("className", dataClass));
		dc.add(Restrictions.eq("classPK", dataKey));
		dc.addOrder(Order.asc("operateTime"));
		List<SynchLogEntity> list = findByDetached(dc);
		return list;
	}
	
	@Override
	public SynchLogEntity findLogByData(String dataClass, String dataKey, String userId, String action) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.eq("className", dataClass));
		dc.add(Restrictions.eq("classPK", dataKey));
		dc.add(Restrictions.eq("targetUser", userId));
		dc.add(Restrictions.eq("action", action));
		List<SynchLogEntity> list = findByDetached(dc);
		if(list != null && !list.isEmpty()){
			return list.get(0);
		}
		return null;
	}
	
	/**
	 * 查询某一数据的最近操作日志
	 */
	@Override
	public SynchLogEntity findLogByData(String clientId, String userId, long timeStamp, String dataClass, String dataKey) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.add(Restrictions.eq("className", dataClass));
		dc.add(Restrictions.eq("classPK", dataKey));
		dc.addOrder(Order.desc("operateTime"));
		
		List<SynchLogEntity> subLogList = findByDetached(dc);
		
		if(subLogList != null && !subLogList.isEmpty()){
			for(SynchLogEntity log : subLogList){
				SynchronizedLogEntity sLog = new SynchronizedLogEntity();
				sLog.setClientId(clientId);
				sLog.setLogId(log.getId());
				sLog.setOperateTime(System.currentTimeMillis());
				sLog.setTargetUser(userId);
				save(sLog);   //保存到同步完成日志表中
			}
			return subLogList.get(0);
		}
		return null;
	}
	
	@Override
	public int countLogByData(String clientId, String userId, long timeStamp, String dataClass, String dataKey) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.add(Restrictions.eq("className", dataClass));
		dc.add(Restrictions.eq("classPK", dataKey));
		
		int count = oConvertUtils.getInt((dc.getExecutableCriteria(getSession())
				.setProjection(Projections.rowCount())).uniqueResult(), 0);
		return count;
	}
	
	/**
	 * 查询条目下附件操作日志
	 * @param clientId
	 * @param userId
	 * @param timeStamp
	 * @param dataClass
	 * @param dataKey
	 * @return
	 */
	@Override
	public SynchLogEntity findAttachmentLogByNote(String clientId, String userId, long timeStamp, String noteId) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		List<String> attaIds = attachmentService.findAttaIdsByNote(noteId, null);
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		if(attaIds != null && !attaIds.isEmpty()){
			dc.add(Restrictions.in("classPK", attaIds));
		}
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.add(Restrictions.eq("className", SynchConstants.DATA_CLASS_ATTACHMENT));
		dc.addOrder(Order.desc("operateTime"));
		
		List<SynchLogEntity> subLogList = findByDetached(dc);
		
		if(subLogList != null && !subLogList.isEmpty()){
			for(SynchLogEntity log : subLogList){
				SynchronizedLogEntity sLog = new SynchronizedLogEntity();
				sLog.setClientId(clientId);
				sLog.setLogId(log.getId());
				sLog.setOperateTime(System.currentTimeMillis());
				sLog.setTargetUser(userId);
				save(sLog);   //保存到同步完成日志表中
			}
			return subLogList.get(0);
		}
		return null;
	}
	
	/**
	 * 查询条目下附件操作日志数量
	 * @param clientId
	 * @param userId
	 * @param timeStamp
	 * @param dataClass
	 * @param dataKey
	 * @return
	 */
	@Override
	public int countAttachmentLogByNote(String clientId, String userId, long timeStamp, String noteId) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		List<String> attaIds = attachmentService.findAttaIdsByNote(noteId, null);
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		if(attaIds != null && !attaIds.isEmpty()){
			dc.add(Restrictions.in("classPK", attaIds));
		}
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.add(Restrictions.eq("className", SynchConstants.DATA_CLASS_ATTACHMENT));
		int count = oConvertUtils.getInt((dc.getExecutableCriteria(getSession())
				.setProjection(Projections.rowCount())).uniqueResult(), 0);
		return count;
	}
	
	/**
	 * 查询专题成员日志
	 * @param clientId
	 * @param userId
	 * @param timeStamp
	 * @param subjectId
	 * @return
	 */
	@Override
	public SynchLogEntity findSubjectUserLogs(String clientId, String userId, long timeStamp, String subjectId) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		dc.add(Restrictions.gt("synchTime", timeStamp));
		//dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.add(Restrictions.ne("clientId", clientId));
		dc.add(Restrictions.eq("className", SynchConstants.DATA_CLASS_SUBJECTUSER));
		dc.add(Restrictions.eq("classPK", subjectId));
		dc.addOrder(Order.desc("operateTime"));
		
		List<SynchLogEntity> subLogList = pageList(dc, 0, SynchConstants.RETURN_CLIENT_MAX_COUNT);
		
		if(subLogList != null && !subLogList.isEmpty()){
			for(SynchLogEntity log : subLogList){
				SynchronizedLogEntity sLog = new SynchronizedLogEntity();
				sLog.setClientId(clientId);
				sLog.setLogId(log.getId());
				sLog.setOperateTime(System.currentTimeMillis());
				sLog.setTargetUser(userId);
				save(sLog);   //保存到同步完成日志表中
			}
			return subLogList.get(0);
		}
		return null;
	}
	
	/**
	 * 查询专题成员日志数量
	 * @param clientId
	 * @param userId
	 * @param timeStamp
	 * @param subjectId
	 * @return
	 */
	@Override
	public int countSubjectUserLogs(String clientId, String userId, long timeStamp, String subjectId) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		dc.add(Restrictions.gt("synchTime", timeStamp));
		//dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.add(Restrictions.ne("clientId", clientId));
		dc.add(Restrictions.eq("className", SynchConstants.DATA_CLASS_SUBJECTUSER));
		dc.add(Restrictions.eq("classPK", subjectId));
		dc.addOrder(Order.desc("operateTime"));
		
		int count = oConvertUtils.getInt((dc.getExecutableCriteria(getSession())
				.setProjection(Projections.rowCount())).uniqueResult(), 0);
		return count;
	}
	
	/**
	 * 查询某专题下数据的日志
	 * @param clientId
	 * @param userId
	 * @param timeStamp
	 * @param subjectId
	 * @return
	 */
	@Override
	public SynchLogEntity findSubjectRelatedLogs(String clientId, String userId, long timeStamp, String subjectId) {
		Group group = groupService.findGroup(SubjectEntity.class.getName(), subjectId);
		//所有该专题下的数据集合，不包括附件
		List<Group> list = groupService.findGroupByParent(group.getGroupId());
		if(list != null && !list.isEmpty()){
			List<String> keysList = new ArrayList<String>();
			for(Group g : list){
				keysList.add(g.getClassPk());
			}
			
			DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
			List<String> idList = findSynchedLogIds(clientId, userId);
			if(idList != null && !idList.isEmpty()){
				dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
			}
			dc.add(Restrictions.gt("synchTime", timeStamp));
			//dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
			dc.add(Restrictions.ne("clientId", clientId));
			dc.add(Restrictions.in("classPK", keysList));
			dc.addOrder(Order.desc("operateTime"));
			
			List<SynchLogEntity> subLogList = pageList(dc, 0, SynchConstants.RETURN_CLIENT_MAX_COUNT);
			
			if(subLogList != null && !subLogList.isEmpty()){
				for(SynchLogEntity log : subLogList){
					SynchronizedLogEntity sLog = new SynchronizedLogEntity();
					sLog.setClientId(clientId);
					sLog.setLogId(log.getId());
					sLog.setOperateTime(System.currentTimeMillis());
					sLog.setTargetUser(userId);
					save(sLog);   //保存到同步完成日志表中
				}
				return subLogList.get(0);
			}
		}
		return null;
	}
	
	@Override
	public int countSubjectRelatedLogs(String clientId, String userId, long timeStamp, String subjectId) {
		Group group = groupService.findGroup(SubjectEntity.class.getName(), subjectId);
		int count = 0;
		//所有该专题下的数据集合，不包括附件
		List<Group> list = groupService.findGroupByParent(group.getGroupId());
		if(list != null && !list.isEmpty()){
			List<String> keysList = new ArrayList<String>();
			for(Group g : list){
				keysList.add(g.getClassPk());
			}
			
			DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
			List<String> idList = findSynchedLogIds(clientId, userId);
			if(idList != null && !idList.isEmpty()){
				dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
			}
			dc.add(Restrictions.gt("synchTime", timeStamp));
			//dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
			dc.add(Restrictions.ne("clientId", clientId));
			dc.add(Restrictions.in("classPK", keysList));
			
			count = oConvertUtils.getInt((dc.getExecutableCriteria(getSession())
					.setProjection(Projections.rowCount())).uniqueResult(), 0);
		}
		return count;
	}
	
	/**
	 * 查询某一类型数据日志
	 * @param dataClass
	 * @return
	 */
	public List<SynchLogEntity> findLogsByDataClass(String dataClass){
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.eq("className", dataClass));
		List<SynchLogEntity> list = findByDetached(dc);
		return list;
	}
	
	public List<SynchLogEntity> findLogsByDataKeys(String dataClass, Collection<String> dataKeys, long timeStamp){
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.eq("className", dataClass));
		dc.add(Restrictions.in("classPK", dataKeys));
		List<SynchLogEntity> list = findByDetached(dc);
		return list;
	}
	
	public List<SynchLogEntity> findLogsByDataKeys(String dataClass, String[] dataKeys, long timeStamp){
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.eq("className", dataClass));
		dc.add(Restrictions.in("classPK", dataKeys));
		List<SynchLogEntity> list = findByDetached(dc);
		return list;
	}
	
	@Override
	public List<SynchLogEntity> findSynchLogsByTarget(String clientId, String userId, long timeStamp, int offset) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.gt("synchTime", timeStamp));
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		dc.addOrder(Order.asc("operateTime"));
		
		List<SynchLogEntity> subLogList = pageList(dc, offset, SynchConstants.RETURN_CLIENT_MAX_COUNT);
		
		return subLogList;
	}
	
	@Override
	public int countSynchLogsByTarget(String clientId, String userId, long timeStamp) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.ge("synchTime", timeStamp));
		
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		int count = oConvertUtils.getInt((dc.getExecutableCriteria(getSession())
				.setProjection(Projections.rowCount())).uniqueResult(), 0);
		return count;
	}
	
	/**
	 * 返回客户端日志查询方法
	 */
	@Override
	public List<SynchLogEntity> findSynchLogsByTarget(String clientId, String userId, long timeStamp, String action, String dataClass, int offset) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchLogEntity.class);
		dc.add(Restrictions.or(Restrictions.and(Restrictions.eq("targetUser", userId), Restrictions.neProperty("operateUser", "targetUser")), Restrictions.and(Restrictions.eq("operateUser", userId), Restrictions.ne("clientId", clientId))));
		//dc.add(Restrictions.eq("clientId", SynchConstants.CLIENT_DEFAULT_ID));   // web页面操作产生的操作日志
		List<String> idList = findSynchedLogIds(clientId, userId);
		if(idList != null && !idList.isEmpty()){
			dc.add(Restrictions.not(Restrictions.in("id", idList)));     //不包括已经同步过的日志
		}
		dc.add(Restrictions.ge("synchTime", timeStamp));
		dc.add(Restrictions.eq("action", action));
		dc.add(Restrictions.eq("className", dataClass));
		dc.addOrder(Order.asc("operateTime"));
		
		List<SynchLogEntity> subLogList = pageList(dc, offset, SynchConstants.RETURN_CLIENT_MAX_COUNT);
		
		return subLogList;
	}
	
	@Override
	public List<String> findSynchedLogIds(String clientId, String userId){
		String sql = "select logId from eht_usedlog where clientId='"+ clientId +"' and targetUser='"+ userId +"'";
		List<String> list = findListbySql(sql);
		return list;
	}

	@Override
	public void deleteSynchedLogs(String clientId, String userId) {
		DetachedCriteria dc = DetachedCriteria.forClass(SynchronizedLogEntity.class);
		dc.add(Restrictions.ge("clientId", clientId));
		dc.add(Restrictions.eq("targetUser", userId));
		List<SynchronizedLogEntity> list = findByDetached(dc);
		deleteAllEntitie(list);
	}
}
