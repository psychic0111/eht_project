package com.eht.webservice.service.impl;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.DELETE;
import javax.ws.rs.DefaultValue;
import javax.ws.rs.FormParam;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.Context;

import org.apache.log4j.Logger;
import org.htmlparser.util.ParserException;
import org.jeecgframework.core.util.JSONHelper;
import org.jeecgframework.core.util.StringUtil;
import org.springframework.beans.factory.annotation.Autowired;

import com.eht.comment.entity.CommentEntity;
import com.eht.comment.service.CommentServiceI;
import com.eht.common.bean.ResponseStatus;
import com.eht.common.cache.DataCacheTool;
import com.eht.common.constant.Constants;
import com.eht.common.constant.ResponseCode;
import com.eht.common.constant.RoleName;
import com.eht.common.constant.SynchConstants;
import com.eht.common.util.FilePathUtil;
import com.eht.common.util.HtmlParser;
import com.eht.common.util.JsonUtil;
import com.eht.common.util.MD5FileUtil;
import com.eht.common.util.ReflectionUtils;
import com.eht.group.service.GroupService;
import com.eht.log.entity.SynchLogEntity;
import com.eht.log.service.SynchLogServiceI;
import com.eht.note.entity.AttachmentEntity;
import com.eht.note.entity.NoteEntity;
import com.eht.note.service.AttachmentServiceI;
import com.eht.note.service.NoteServiceI;
import com.eht.role.entity.Role;
import com.eht.role.entity.RoleUser;
import com.eht.role.service.RoleService;
import com.eht.subject.entity.DirectoryEntity;
import com.eht.subject.entity.SubjectEntity;
import com.eht.subject.service.DirectoryServiceI;
import com.eht.subject.service.SubjectServiceI;
import com.eht.system.service.DataInitService;
import com.eht.tag.entity.TagEntity;
import com.eht.tag.service.TagServiceI;
import com.eht.template.entity.TemplateEntity;
import com.eht.template.service.TemplateServiceI;
import com.eht.user.entity.AccountEntity;
import com.eht.user.service.AccountServiceI;
import com.eht.webservice.service.DataSynchizeService;
import com.eht.webservice.service.util.DataSynchizeUtil;

public class DataSynchizeServiceImpl implements DataSynchizeService {

	private Logger logger = Logger.getLogger(DataSynchizeServiceImpl.class);

	@Autowired
	private AccountServiceI accountService;

	@Autowired
	private DataInitService dataInitService;

	@Autowired
	private GroupService groupService;

	@Autowired
	private NoteServiceI noteService;

	@Autowired
	private DirectoryServiceI directoryService;

	@Autowired
	private TagServiceI tagService;

	@Autowired
	private TemplateServiceI templateService;

	@Autowired
	private CommentServiceI commentService;

	@Autowired
	private AttachmentServiceI attachmentService;

	@Autowired
	private SubjectServiceI subjectService;

	@Autowired
	private RoleService roleService;

	@Autowired
	private SynchLogServiceI synchLogService;

	@Override
	@POST
	@Path("/uploadImage/{noteId}/{imgId}/{fileName}")
	public String uploadImage(@PathParam("noteId") String noteId, @PathParam("imgId") String imgId, @PathParam("fileName") String fileName, @Context HttpServletRequest request) throws IOException, ParserException {
		ResponseStatus res = new ResponseStatus(); // 上传文件操作结果
		InputStream ins = null;
		OutputStream ous = null;
		NoteEntity note = noteService.getNote(noteId);
		AttachmentEntity atta = new AttachmentEntity();
		String imgPath = FilePathUtil.getImageUploadPath(note);
		File folder = new File(imgPath);
		if (!folder.exists()) {
			folder.mkdirs();
		}
		File file = new File(imgPath + File.separator + fileName + ".tmp");
		try {
			ins = request.getInputStream();
			ous = new FileOutputStream(file);
			int n = 0;
			int buffer = 1024;
			byte[] bytes = new byte[buffer];
			while ((n = ins.read(bytes)) != -1) {
				ous.write(bytes, 0, n);
			}

		} catch (Exception e) {
			res = new ResponseStatus(ResponseCode.SERVER_ERROR);
			e.printStackTrace();
			return res.toString();
		} finally {
			ous.flush();
			ous.close();
			ins.close();
			File image = new File(imgPath + File.separator + fileName);
			file.renameTo(image);
			atta.setId(imgId);
			atta.setNoteId(noteId);
			atta.setCreateTime(note.getCreateTime());
			atta.setCreateUser(note.getCreateUser());
			atta.setDeleted(Constants.DATA_NOT_DELETED);
			atta.setFileName(fileName);
			atta.setFilePath(imgPath);
			atta.setFileType(Constants.FILE_TYPE_IMAGE);
			atta.setMd5(MD5FileUtil.getFileMD5String(image));
			atta.setSuffix(fileName.substring(fileName.lastIndexOf('.') + 1));
			atta.setStatus(Constants.FILE_TRANS_COMPLETED);
			attachmentService.addAttachment(atta);

			HtmlParser parser = new HtmlParser(note.getContent());
			String imgUrl = FilePathUtil.getImageUrl(note);
			String content = parser.parseNoteContent(imgId, imgUrl + "/" + fileName);
			note.setContent(content);
			noteService.updateEntitie(note);
		}
		return res.toString();
	}

	@Override
	@POST
	@Path("/upload/{attachmentId}")
	public String uploadAttachment(@PathParam("attachmentId") String attachmentId, @Context HttpServletRequest request) {
		ResponseStatus res = new ResponseStatus(); // 上传文件操作结果
		AttachmentEntity attachment = attachmentService.getAttachment(attachmentId);
		AttachmentEntity attaServer = attachmentService.findAttachmentByMd5(attachment.getMd5());
		// 服务器存在相同文件
		if (attaServer != null && attaServer.getStatus() == 1) {
			logger.info("服务器存在该文件，直接复制服务器文件！！！");
			res = DataSynchizeUtil.copyServerFile(attaServer, attachment);
			attachmentService.updateAttachment(attachment);
			return res.toString();
		}

		// 上次已经上传过该文件或分块传输
		if ((attachment.getTranSfer() != null && attachment.getTranSfer() > 0 && attachment.getStatus() == 0)) {
			logger.info("上次传输文件中断，共传输了" + attachment.getTranSfer() + "字节，准备继续传输！！！");
			return resumeUploadAttachment(attachmentId, 1, request); // 1默认文件数据都提交过来
		}

		InputStream ins = null;
		OutputStream ous = null;
		long transfered = 0; // 已传输字节
		attachment.setStatus(0); // 文件上传未完成

		File folder = new File(attachment.getFilePath());
		if (!folder.exists()) {
			folder.mkdirs();
		}
		File file = new File(attachment.getFilePath() + File.separator + attachment.getFileName() + ".tmp");
		try {
			ins = request.getInputStream();
			ous = new FileOutputStream(file);
			int n = 0;
			int buffer = 1024;
			byte[] bytes = new byte[buffer];
			while ((n = ins.read(bytes)) != -1) {
				ous.write(bytes, 0, n);
				transfered += n;
			}

			logger.info("文件分块传输完成，本次共传输：" + transfered + "字节。");
			attachment.setStatus(Constants.FILE_TRANS_COMPLETED);
		} catch (Exception e) {
			res = new ResponseStatus(ResponseCode.SERVER_ERROR);
			e.printStackTrace();
			return res.toString();
		} finally {
			try {
				ous.flush();
				ous.close();
				ins.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			attachment.setTranSfer(transfered);
			attachmentService.updateAttachment(attachment);
			logger.info("文件分块传输完成，更新数据库文件状态！");
			if (attachment.getStatus() != null && attachment.getStatus() == 1) {
				file.renameTo(new File(attachment.getFilePath() + File.separator + attachment.getFileName()));
			}
		}
		return res.toString();
	}

	/**
	 * 续传文件
	 */
	@Override
	@POST
	@Path("/upload/resume/{attachmentId}/{flag}")
	public String resumeUploadAttachment(@PathParam("attachmentId") String attachmentId, @DefaultValue("1") @PathParam("attachmentId") int flag, @Context HttpServletRequest request) {
		ResponseStatus res = new ResponseStatus(); // 上传文件操作结果
		AttachmentEntity attachment = attachmentService.getAttachment(attachmentId);
		AttachmentEntity attaServer = attachmentService.findAttachmentByMd5(attachment.getMd5());
		// 服务器存在相同文件
		if (attaServer != null) {
			logger.info("服务器存在该文件，直接复制服务器文件！！！");
			res = DataSynchizeUtil.copyServerFile(attaServer, attachment);
			attachmentService.updateAttachment(attachment);

			// 删除原上传临时文件
			File file = new File(attachment.getFilePath() + File.separator + attachment.getFileName() + ".tmp");
			file.delete();
			return res.toString();
		}

		InputStream ins = null;
		long transfered = attachment.getTranSfer() == null ? 0 : attachment.getTranSfer(); // 已传输字节
		attachment.setStatus(0); // 文件上传未完成

		File folder = new File(attachment.getFilePath());
		if (!folder.exists()) {
			folder.mkdirs();
		}
		File file = new File(attachment.getFilePath() + File.separator + attachment.getFileName() + ".tmp");
		if (!file.exists()) {
			try {
				file.createNewFile();
				logger.info("续传文件不存在，创建文件：" + file.getName());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
		RandomAccessFile raf = null;
		try {
			raf = new RandomAccessFile(file, "rw");
			long length = Long.parseLong(request.getHeader("Content-Length"));
			raf.setLength(transfered + length);
			ins = request.getInputStream();
			int n = 0;
			int buffer = 1024;
			byte[] bytes = new byte[buffer];
			while ((n = ins.read(bytes)) != -1) {
				raf.seek(transfered);
				raf.write(bytes, 0, n);
				transfered += n;
			}

			if (flag == 1) {
				logger.info("文件传输完成，共传输：" + transfered + "字节。");
				attachment.setStatus(1); // 文件保存完成
			} else {
				logger.info("文件分块传输完成，本次共传输：" + transfered + "字节。");
			}
		} catch (Exception e) {
			res = new ResponseStatus(ResponseCode.SERVER_ERROR);
			e.printStackTrace();
			return res.toString();
		} finally {
			try {
				raf.close();
				ins.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
			attachment.setTranSfer(transfered);
			attachmentService.updateAttachment(attachment);
			logger.info("文件分块传输完成，更新数据库文件状态！");
			if (attachment.getStatus() != null && attachment.getStatus() == 1) {
				file.renameTo(new File(attachment.getFilePath() + File.separator + attachment.getFileName()));
			}
		}
		return res.toString();
	}

	@Override
	@POST
	@Path("/upload_batch")
	public String uploadAttachmentBatch(@FormParam("attachmentId") String[] attachmentId, @Context HttpServletRequest request) {
		String result = (new ResponseStatus()).toString();
		for (int i = 0; i < attachmentId.length; i++) {
			result = uploadAttachment(attachmentId[i], request);
			ResponseStatus res = JSONHelper.fromJsonToObject(result, ResponseStatus.class);
			if (res.getStatus() != ResponseCode.NEXT_RECORD.getCode()) {
				return result;
			}
		}
		return result;
	}

	@Override
	@GET
	@Path("/download/{attachmentId}")
	public String downloadAttachment(@PathParam("attachmentId") String attachmentId, @Context HttpServletResponse response) throws Exception {
		AttachmentEntity attachment = attachmentService.getAttachment(attachmentId);
		File file = new File(attachment.getFilePath() + File.separator + attachment.getFileName());
		FileInputStream fis = new FileInputStream(file);
		int length = fis.available();
		byte[] b = new byte[length];
		fis.read(b);

		response.setHeader("Content-Disposition", "attachment; filename=\"" + attachment.getFileName() + "\"");
		response.addHeader("Content-Length", "" + length);
		response.setContentType("application/octet-stream;charset=UTF-8");
		OutputStream outputStream = new BufferedOutputStream(response.getOutputStream());
		outputStream.write(b);
		ResponseStatus res = new ResponseStatus(); // 上传文件操作结果

		outputStream.flush();
		outputStream.close();
		fis.close();
		return res.toString();
	}

	@Override
	@GET
	@Path("/download_batch")
	public String downloadAttachmentBatch(@FormParam("attachmentId") String[] attachmentId) {
		return null;
	}

	@Override
	@POST
	@Path("/send/attachment/a/{timeStamp}")
	public String addAttachment(@FormParam("data") String data, @PathParam("timeStamp") long timeStamp) throws ParserException {
		logger.info("添加附件信息 ！！！");
		AttachmentEntity attachment = (AttachmentEntity) JsonUtil.getObject4JsonString(data, AttachmentEntity.class);
		NoteEntity note = noteService.getNote(attachment.getNoteId());
		if (attachment.getFileType().intValue() == Constants.FILE_TYPE_NORMAL) {
			String filePath = FilePathUtil.getFileUploadPath(note, attachment.getDirectoryId());
			attachment.setFilePath(filePath);
		} else {
			String filePath = FilePathUtil.getImageUploadPath(note);
			attachment.setFilePath(filePath);
			HtmlParser parser = new HtmlParser(note.getContent());
			String imgUrl = FilePathUtil.getImageUrl(note);
			String content = parser.parseNoteContent(attachment.getId(), imgUrl + "/" + attachment.getFileName());
			note.setContent(content);
			noteService.updateEntitie(note);
		}
		attachment.setDeleted(Constants.DATA_NOT_DELETED);
		attachment.setStatus(Constants.FILE_TRANS_NOT_COMPLETED);
		attachment.setTranSfer(0L);
		AccountEntity user = accountService.getUser4Session();
		attachment.setCreateUser(user.getId());
		attachmentService.addAttachment(attachment);
		
		ResponseStatus rs = new ResponseStatus();
		int count = synchLogService.countAttachmentLogByNote(user.getClientId(), user.getId(), timeStamp, attachment.getNoteId());
		if(count > 0){
			rs.setResponse(ResponseCode.NEED_SYNCH_ATTACHMENT);
			rs.setData(attachment.getNoteId());
		}
		return rs.toString();
	}

	@Override
	@DELETE
	@Path("/send/attachment/d/{id}/{timeStamp}")
	public String deleteAttachment(@PathParam("id") String id, @PathParam("timeStamp") long timeStamp) {
		logger.info("删除附件信息 ！！！");
		AttachmentEntity attachment = attachmentService.getAttachment(id);
		AccountEntity user = accountService.getUser4Session();
		if(attachment != null && attachment.getDeleted() == Constants.DATA_NOT_DELETED){
			attachment.setUpdateUser(user.getId());
			attachmentService.markDelAttachment(attachment);
		}
		
		ResponseStatus rs = new ResponseStatus();
		int count = synchLogService.countAttachmentLogByNote(user.getClientId(), user.getId(), timeStamp, attachment.getNoteId());
		if(count > 0){
			rs.setResponse(ResponseCode.NEED_SYNCH_ATTACHMENT);
			rs.setData(attachment.getNoteId());
		}
		return rs.toString();
	}

	@Override
	@GET
	@Path("/get_count/{clientId}/{userId}/{timeStamp}")
	public int countSynchData(@PathParam("clientId") String clientId, @PathParam("userId") String userId, @PathParam("timeStamp") String timeStamp) {
		long time = Long.parseLong(timeStamp);
		int count = synchLogService.countSynchLogsByTarget(clientId, userId, time);
		return count;
	}

	@SuppressWarnings({"rawtypes", "unchecked"})
	@Override
	@GET
	@Path("/get_data/{clientId}/{userId}/{timeStamp}/{offset}")
	public String getSynchData(@PathParam("clientId") String clientId, @PathParam("userId") String userId, @PathParam("timeStamp") String timeStamp, @DefaultValue("0") @PathParam("offset") int offset) {
		long time = Long.parseLong(timeStamp);
		Map map = new HashMap();
		List<SynchLogEntity> logList = synchLogService.findSynchLogsByTarget(clientId, userId, time, offset);
		if (logList != null && !logList.isEmpty()) {
			SynchLogEntity log = logList.get(0);
			Serializable data = null;
			// 删除操作不需要取数据
			if (!log.getAction().equals(SynchConstants.DATA_OPERATE_DELETE) && !log.getClassName().equals(SynchConstants.DATA_CLASS_DIRECTORYBLACK) && !log.getClassName().equals(SynchConstants.DATA_CLASS_NOTEBLACK)
					&& !log.getClassName().equals(SynchConstants.DATA_CLASS_SUBJECTUSER)) {
				Class c = DataCacheTool.getDataClass(log.getClassName());
				data = synchLogService.getEntity(c, log.getClassPK());
			}
			String dataJson = JsonUtil.bean2json(data);
			map = JsonUtil.getMap4Json(dataJson);
			map.put("action", log.getAction());
			map.put("className", log.getClassName());
			map.put("classPK", log.getClassPK());
			map.put("operateTime", log.getOperateTime());
			map.put("flag", "NEXT");
		} else {
			map.put("flag", "FINISHED");
		}

		return JsonUtil.map2json(map);
	}

	@SuppressWarnings({"rawtypes", "unchecked"})
	@Override
	@GET
	@Path("/get/{clientId}/{userId}/{timeStamp}/{offset}")
	public String getSynchDataByStep(@PathParam("clientId") String clientId, @PathParam("userId") String userId, @PathParam("timeStamp") long timeStamp, @DefaultValue("SUBJECT") @QueryParam("className") String className, @DefaultValue("A") @QueryParam("operation") String action,
			@DefaultValue("0") @PathParam("offset") int offset) {
		Map map = new HashMap();
		String[] actions = DataCacheTool.getActionSort();
		String[] dataClasses = DataCacheTool.getDatasSort();

		int index = 0;
		for (int i = 0; i < actions.length; i++) {
			String act = actions[i];
			if(act.equals(action)){
				for (int k = 0; k < dataClasses.length; k++) {
					String dataClass = dataClasses[k];
					if (dataClass.equals(className)) {
						List<SynchLogEntity> logList = synchLogService.findSynchLogsByTarget(clientId, userId, timeStamp, act, className, offset);
						if (logList == null || logList.isEmpty()) {  // 没查询到日志
							index = k + 1;
							map.put("offset", 0);
							map.put("NEXT_OPERATION", act);
							if (index == dataClasses.length && i == actions.length - 1) {   //所有类型数据已查询完毕
								map.put("NEXT", "FINISHED");
								map.put("NEXT_OPERATION", "FINISHED");
								//同步完成，删除中间表相关记录
								synchLogService.deleteSynchedLogs(clientId, userId);
							} else if(index == dataClasses.length && i < actions.length - 1){
								map.put("NEXT", dataClasses[0]);        //下一个操作类型同步从第一个数据类型开始
								map.put("NEXT_OPERATION", actions[i + 1]); //下次开始返回下一个操作类型
							} else if(index < dataClasses.length && i <= actions.length - 1){
								map.put("NEXT", dataClasses[index]);
							}
							return JsonUtil.map2json(map);
						} else {
							SynchLogEntity log = logList.get(0);
							Serializable data = null;
							// 删除操作不需要取数据
							if (!log.getAction().equals(SynchConstants.DATA_OPERATE_DELETE) && !log.getClassName().equals(SynchConstants.DATA_CLASS_DIRECTORYBLACK) && !log.getClassName().equals(SynchConstants.DATA_CLASS_NOTEBLACK)
									&& !log.getClassName().equals(SynchConstants.DATA_CLASS_SUBJECTUSER)) {
								Class c = DataCacheTool.getDataClass(log.getClassName());
								data = synchLogService.getEntity(c, log.getClassPK());
								String dataJson = JsonUtil.bean2json(data);
								map = JsonUtil.getMap4Json(dataJson);
							}
							map.put("operation", log.getAction());
							map.put("className", log.getClassName());
							map.put("classPK", log.getClassPK());
							map.put("operateTime", log.getOperateTime());
							map.put("NEXT", dataClass);
							map.put("NEXT_OPERATION", act);
							map.put("offset", String.valueOf(offset + 1));
							return JsonUtil.map2json(map);
						}
					}
				}
				// 一操作下所有数据类型日志都查询完，开始下一操作类型日志
				if(i <= action.length() - 1){
					map.put("NEXT", dataClasses[0]);
					map.put("NEXT_OPERATION", actions[i + 1]);
				}
				
			}
		}
		//同步完成，删除中间表相关记录
		synchLogService.deleteSynchedLogs(clientId, userId);
				
		map.put("NEXT", "FINISHED");
		map.put("NEXT_ACTION", "FINISHED");
		map.put("offset", 0);
		return JsonUtil.map2json(map);
	}
	
	@Override
	@GET
	@Path("/get/{logId}")
	public String getSynchDataByLogId(@PathParam("logId") String logId) {
		SynchLogEntity log = synchLogService.getSynchLog(logId);
		Map<String, Object> map = DataSynchizeUtil.parseLog(log);
		return JsonUtil.map2json(map);
	}
	
	@Override
	@POST
	@Path("/send/client/a/{clientType}")
	public String registerClient(@PathParam("clientType") String clientType) {
		String clientId = dataInitService.registerClient(clientType);
		return clientId;
	}

	@Override
	@DELETE
	@Path("/send/client/d/{clientId}")
	public String deleteClient(@PathParam("clientId") String clientId) {
		dataInitService.deleteClient(clientId);
		return "true";
	}

	@Override
	@POST
	@Path("/send/subject/a")
	public String addSubject(@FormParam("data") String data) {
		logger.info("添加专题信息 ！！！");
		AccountEntity user = accountService.getUser4Session();
		SubjectEntity subject = (SubjectEntity) JsonUtil.getObject4JsonString(data, SubjectEntity.class);
		subject.setCreateUser(user.getId());
		subjectService.addSubject(subject);
		
		ResponseStatus rs = new ResponseStatus();
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/subject/u/{timeStamp}")
	public String updateSubject(@FormParam("data") String data, @PathParam("timeStamp") long timeStamp) throws IllegalAccessException, InvocationTargetException {
		logger.info("更新专题信息 ！！！");
		AccountEntity user = accountService.getUser4Session();
		SubjectEntity subject = (SubjectEntity) JsonUtil.getObject4JsonString(data, SubjectEntity.class);
		SubjectEntity sub = subjectService.getSubject(subject.getId());
		ResponseStatus rs =new ResponseStatus();
		SynchLogEntity log = synchLogService.findLogByData(user.getClientId(), user.getId(), timeStamp, SynchConstants.DATA_CLASS_SUBJECT, sub.getId());
		if(sub != null && sub.getDeleted() == Constants.DATA_NOT_DELETED){  // 服务器存在此专题，并且不是删除状态
			//服务器上不存在该数据其它操作日志，或者有修改操作日志并且操作早于此次操作，才更新数据库数据
			if(log == null || (log.getAction().equals(SynchConstants.DATA_OPERATE_UPDATE) && log.getOperateTime() < subject.getUpdateTimeStamp())){
				sub.setUpdateUserId(user.getId());
				sub.setDeleted(Constants.DATA_NOT_DELETED);
				sub.setStatus(Constants.ENABLED);
				ReflectionUtils.copyBeanProperties(subject, sub);
				subjectService.updateSubject(sub);
			}
		}else{
			rs.setResponse(ResponseCode.NEED_DELETE);
			/*SynchLogEntity log = synchLogService.findLogByData(SynchConstants.DATA_CLASS_SUBJECT, subject.getId(), user.getId(), SynchConstants.DATA_OPERATE_DELETE);
			rs.setResponse(ResponseCode.NEED_DELETE);
			Map<String, Object> map = DataSynchizeUtil.parseLog(log);
			rs.setData(map);
			return rs.toString();*/
		}
		if(log != null){
			if(log.getAction().equals(SynchConstants.DATA_OPERATE_DELETE)){
				rs.setResponse(ResponseCode.NEED_DELETE);
				/*Map<String, Object> map = DataSynchizeUtil.parseLog(log);
				rs.setData(map);*/
			}else if(log.getAction().equals(SynchConstants.DATA_OPERATE_UPDATE)){
				rs.setResponse(ResponseCode.NEED_UPDATE);
				rs.setData(log.getId());
			}
		}else if(subject.getSubjectType() == Constants.SUBJECT_TYPE_M){
			//查询专题成员相关操作日志
			int count = synchLogService.countSubjectUserLogs(user.getClientId(), user.getId(), timeStamp, sub.getId());
			if(count > 0){
				rs.setResponse(ResponseCode.NEED_SYNCH_SUBJECTUSER);
			}
		}
		return rs.toString();
	}

	@Override
	@DELETE
	@Path("/send/subject/d/{id}")
	public String deleteSubject(@PathParam("id") String id) {
		logger.info("删除专题信息 ！！！");
		SubjectEntity subject = subjectService.getSubject(id);
		if(subject != null && subject.getDeleted() == Constants.DATA_NOT_DELETED){
			AccountEntity user = accountService.getUser4Session();
			subject.setUpdateUser(user.getId());
			subjectService.markDelSubject(subject);
		}
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/directory/a")
	public String addDirectory(@FormParam("data") String data) {
		logger.info("添加目录信息 ！！！");
		DirectoryEntity dir = (DirectoryEntity) JsonUtil.getObject4JsonString(data, DirectoryEntity.class);
		AccountEntity user = accountService.getUser4Session();
		dir.setCreateUser(user.getId());
		dir.setDeleted(Constants.DATA_NOT_DELETED);
		directoryService.addDirectory(dir);
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/directory/u/{timeStamp}")
	public String updateDirectory(@FormParam("data") String data, @PathParam("timeStamp") long timeStamp) throws IllegalAccessException, InvocationTargetException {
		logger.info("更新目录信息 ！！！");
		DirectoryEntity directory = (DirectoryEntity) JsonUtil.getObject4JsonString(data, DirectoryEntity.class);
		DirectoryEntity dir = directoryService.getDirectory(directory.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		SynchLogEntity log = synchLogService.findLogByData(user.getClientId(), user.getId(), timeStamp, SynchConstants.DATA_CLASS_DIRECTORY, directory.getId());
		if (dir != null && dir.getDeleted() == Constants.DATA_NOT_DELETED) {
			//服务器上不存在该数据其它操作日志，或者有修改操作日志并且操作早于此次操作，才更新数据库数据
			if(log == null || (log.getAction().equals(SynchConstants.DATA_OPERATE_UPDATE) && log.getOperateTime() < directory.getUpdateTimeStamp())){
				directory.setUpdateUserId(user.getId());
				directory.setDeleted(Constants.DATA_NOT_DELETED);
				ReflectionUtils.copyBeanProperties(directory, dir);
				directoryService.updateDirectory(dir);
			}
		}else{
			rs.setResponse(ResponseCode.NEED_DELETE);
		}
		
		if(log != null){
			if(log.getAction().equals("D")){
				rs.setResponse(ResponseCode.NEED_DELETE);
				/*Map<String, Object> map = DataSynchizeUtil.parseLog(log);
				rs.setData(map);*/
			}else if(log.getAction().equals("U")){
				rs.setResponse(ResponseCode.NEED_UPDATE);
				rs.setData(log.getId());
			}
		}
		return rs.toString();
	}

	@Override
	@DELETE
	@Path("/send/directory/d/{id}")
	public String deleteDirectory(@PathParam("id") String id) {
		logger.info("删除目录信息 ！！！");
		DirectoryEntity dir = directoryService.getDirectory(id);
		if(dir != null && dir.getDeleted() == Constants.DATA_NOT_DELETED){
			AccountEntity user = accountService.getUser4Session();
			dir.setUpdateUser(user.getId());
			directoryService.markDelDirectory(dir);
		}
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/directoryblack/a/{directoryId}/{userId}")
	public String addDirectoryBlack(@PathParam("directoryId") String directoryId, @PathParam("userId") String userId) {
		directoryService.blacklistedUser(userId, directoryId);
		return new ResponseStatus().toString();
	}

	@Override
	@DELETE
	@Path("/send/directoryblack/d/{directoryId}/{userId}")
	public String deleteDirectoryBlack(@PathParam("directoryId") String directoryId, @PathParam("userId") String userId) {
		directoryService.removeUser4lacklist(userId, directoryId);
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/note/a")
	public String addNote(@FormParam("data") String data) {
		logger.info("添加条目信息 ！！！");
		NoteEntity note = (NoteEntity) JsonUtil.getObject4JsonString(data, NoteEntity.class);
		AccountEntity user = accountService.getUser4Session();
		note.setMd5(MD5FileUtil.getMD5String(note.getContent()));
		note.setCreateUser(user.getId());
		note.setDeleted(Constants.DATA_NOT_DELETED);
		noteService.addNote(note);
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/note/u/{timeStamp}")
	public String updateNote(@FormParam("data") String data, @PathParam("timeStamp") long timeStamp, @DefaultValue("true") @QueryParam("updateContent") boolean updateContent) throws IllegalAccessException, InvocationTargetException {
		logger.info("更新条目基本信息 ！！！");
		NoteEntity note = (NoteEntity) JsonUtil.getObject4JsonString(data, NoteEntity.class);
		NoteEntity n = noteService.getNote(note.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		SynchLogEntity log = synchLogService.findLogByData(user.getClientId(), user.getId(), timeStamp, SynchConstants.DATA_CLASS_NOTE, note.getId());
		if (n != null && n.getDeleted() == Constants.DATA_NOT_DELETED){
			//服务器上不存在该数据其它操作日志，或者有修改操作日志并且操作早于此次操作，才更新数据库数据
			if(log == null || (log.getAction().equals(SynchConstants.DATA_OPERATE_UPDATE) && log.getOperateTime() < note.getUpdateTimeStamp())){
				note.setUpdateUserId(user.getId());
				note.setDeleted(Constants.DATA_NOT_DELETED);
				ReflectionUtils.copyBeanProperties(note, n);
				noteService.updateNote(n, updateContent);
				noteService.saveNoteHistory(note, user.getId());
			}else if(log.getOperateTime() > note.getUpdateTimeStamp()){
				noteService.saveNoteHistory(note, user.getId());
			}
		}else{
			rs.setResponse(ResponseCode.NEED_DELETE);
			return rs.toString();
		}

		if(log != null){
			if(log.getAction().equals("D")){
				rs.setResponse(ResponseCode.NEED_DELETE);
				/*Map<String, Object> map = DataSynchizeUtil.parseLog(log);
				rs.setData(map);*/
			}else if(log.getAction().equals("U")){
				rs.setResponse(ResponseCode.NEED_UPDATE);
				rs.setData(log.getId());
			}
		}else{
			// 查询条目下附件日志
			int count = synchLogService.countAttachmentLogByNote(user.getClientId(), user.getId(), timeStamp, note.getId());
			if(count > 0){
				rs.setResponse(ResponseCode.NEED_SYNCH_ATTACHMENT);
				rs.setData(note.getId());
			}
		}
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/note/u/{id}")
	public String updateNoteContent(@PathParam("id") String id, @FormParam("content") String content) {
		logger.info("更新条目内容 ！！！");
		NoteEntity oldNote = noteService.getNote(id);

		String md5 = MD5FileUtil.getMD5String(content);
		if (!oldNote.getMd5().equals(md5)) {
			oldNote.setMd5(md5);
			oldNote.setContent(content);
		}
		noteService.updateNote(oldNote, true);
		return oldNote.getId();
	}

	@Override
	@DELETE
	@Path("/send/note/d/{id}")
	public String deleteNote(@PathParam("id") String id) {
		NoteEntity oldNote = noteService.getNote(id);
		if(oldNote != null && oldNote.getDeleted() == Constants.DATA_NOT_DELETED){
			AccountEntity user = accountService.getUser4Session();
			oldNote.setUpdateUser(user.getId());
			noteService.markDelNote(oldNote);
		}
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/noteblack/a/{noteId}/{userId}")
	public String addNoteBlack(@PathParam("noteId") String noteId, @PathParam("userId") String userId) {
		noteService.blacklistedUser(userId, noteId);
		return new ResponseStatus().toString();
	}

	@Override
	@DELETE
	@Path("/send/noteblack/d/{noteId}/{userId}")
	public String deleteNoteBlack(@PathParam("noteId") String noteId, @PathParam("userId") String userId) {
		noteService.removeUser4blacklist(userId, noteId);
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/tag/a")
	public String addTag(@FormParam("data") String data) {
		TagEntity tag = (TagEntity) JsonUtil.getObject4JsonString(data, TagEntity.class);
		AccountEntity user = accountService.getUser4Session();
		tag.setCreateUser(user.getId());
		tag.setDeleted(Constants.DATA_NOT_DELETED);
		tagService.addTag(tag);
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/tag/u/{timeStamp}")
	public String updateTag(@FormParam("data") String data, @PathParam("timeStamp") long timeStamp) throws IllegalAccessException, InvocationTargetException {
		logger.info("更新标签信息 ！！！");
		TagEntity tag = (TagEntity) JsonUtil.getObject4JsonString(data, TagEntity.class);
		TagEntity t = tagService.getTag(tag.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		SynchLogEntity log = synchLogService.findLogByData(user.getClientId(), user.getId(), timeStamp, SynchConstants.DATA_CLASS_DIRECTORY, tag.getId());
		if (t != null) {
			//服务器上不存在该数据其它操作日志，或者有修改操作日志并且操作早于此次操作，才更新数据库数据
			if(log == null || (log.getAction().equals(SynchConstants.DATA_OPERATE_UPDATE) && log.getOperateTime() < tag.getUpdateTimeStamp())){
				tag.setUpdateUser(user.getId());
				ReflectionUtils.copyBeanProperties(tag, t);
				tagService.updateTag(t);
			}
		}else{
			rs.setResponse(ResponseCode.NEED_DELETE);
		}
		
		if(log != null){
			if(log.getAction().equals("D")){
				rs.setResponse(ResponseCode.NEED_DELETE);
				/*Map<String, Object> map = DataSynchizeUtil.parseLog(log);
				rs.setData(map);*/
			}else if(log.getAction().equals("U")){
				rs.setResponse(ResponseCode.NEED_UPDATE);
				rs.setData(log.getId());
			}
		}
		return rs.toString();
	}

	@Override
	@DELETE
	@Path("/send/tag/d/{id}")
	public String deleteTag(@PathParam("id") String id) {
		logger.info("删除标签信息 ！！！");
		TagEntity tag = tagService.getTag(id);
		if(tag != null){
			tagService.deleteTag(tag);
		}
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/template/a")
	public String addTemplate(@FormParam("data") String data) {
		logger.info("添加模板信息 ！！！");
		TemplateEntity template = (TemplateEntity) JsonUtil.getObject4JsonString(data, TemplateEntity.class);
		String templateId = templateService.addTemplate(template);
		return templateId;
	}

	@Override
	@POST
	@Path("/send/comment/a")
	public String addComment(@FormParam("data") String data) {
		CommentEntity comment = (CommentEntity) JsonUtil.getObject4JsonString(data, CommentEntity.class);
		AccountEntity user = accountService.getUser4Session();
		comment.setCreateUser(user.getId());
		commentService.addComment(comment);
		return new ResponseStatus().toString();
	}

	@Override
	@DELETE
	@Path("/send/comment/d/{id}")
	public String deleteComment(@PathParam("id") String id) {
		CommentEntity comment = commentService.getComment(id);
		if(comment != null){
			commentService.deleteComment(comment);
		}
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/user/u")
	public String updateUser(@FormParam("data") String data) {
		AccountEntity user = (AccountEntity) JsonUtil.getObject4JsonString(data, AccountEntity.class);
		accountService.updateEntitie(user);
		return new ResponseStatus().toString();
	}

	@Override
	@GET
	@Path("/get_user/{id}")
	public String getUserInfo(@PathParam("id") String id) {
		AccountEntity user = accountService.getUser(id);
		return JsonUtil.bean2json(user);
	}
	
	@Override
	@GET
	@Path("/get/subjectuser/{subjectId}/{clientId}/{userId}/{timeStamp}")
	public String getSubjectUser(@PathParam("subjectId") String subjectId, @PathParam("clientId") String clientId, @PathParam("userId") String userId, @PathParam("timeStamp") long timeStamp) {
		SynchLogEntity log = synchLogService.findSubjectUserLogs(clientId, userId, timeStamp, subjectId);
		Map<String, Object> map = new HashMap<String, Object>();
		if(log != null){
			String memberId = log.getTargetUser();
			RoleUser ru = roleService.findUserRole(memberId, subjectId);
			map = DataSynchizeUtil.parseLog(log);
			map.put("subjectId", subjectId);
			map.put("userId", memberId);
			map.put("roleId", ru.getRoleId());
		}else{
			map.put("response", ResponseCode.PART_SYNCH_FINISHED.toString());
		}
		int count = synchLogService.countSubjectUserLogs(clientId, userId, timeStamp, subjectId);
		if(count > 0){
			map.put("response", ResponseCode.NEED_SYNCH_SUBJECTUSER.toString());
		}else{
			map.put("response", ResponseCode.PART_SYNCH_FINISHED.toString());
		}
		return JsonUtil.map2json(map);
	}
	
	@Override
	@GET
	@Path("/get/subjectdata/{subjectId}/{clientId}/{userId}/{timeStamp}")
	public String getSubjectRelatedLogs(@PathParam("subjectId") String subjectId, @PathParam("clientId") String clientId, @PathParam("userId") String userId, @PathParam("timeStamp") long timeStamp) {
		int count = synchLogService.countSubjectRelatedLogs(clientId, userId, timeStamp, subjectId);
		if(count > 0){
			SynchLogEntity log = synchLogService.findSubjectRelatedLogs(clientId, userId, timeStamp, subjectId);
			Map<String, Object> map = DataSynchizeUtil.parseLog(log);
			if(count > 1){
				map.put("response", ResponseCode.NEED_SUBJECT_DATA.toString());
			}else{
				map.put("response", ResponseCode.PART_SYNCH_FINISHED.toString());
			}
			return JsonUtil.map2json(map);
		}
		return new ResponseStatus().toString();
	}
	
	@Override
	@GET
	@Path("/get/attachment/{noteId}/{clientId}/{userId}/{timeStamp}")
	public String getNoteAttachment(@PathParam("noteId") String noteId, @PathParam("clientId") String clientId, @PathParam("userId") String userId, @PathParam("timeStamp") long timeStamp) {
		SynchLogEntity log = synchLogService.findAttachmentLogByNote(clientId, userId, timeStamp, noteId);
		Map<String, Object> map = new HashMap<String, Object>();
		if(log != null){
			map = DataSynchizeUtil.parseLog(log);
		}else{
			map.put("response", ResponseCode.PART_SYNCH_FINISHED.toString());
		}
		int count = synchLogService.countAttachmentLogByNote(clientId, userId, timeStamp, noteId);
		if(count > 0){
			map.put("response", ResponseCode.NEED_SYNCH_ATTACHMENT.toString());
		}else{
			map.put("response", ResponseCode.PART_SYNCH_FINISHED.toString());
		}
		return JsonUtil.map2json(map);
	}
	
	@Override
	@POST
	@Path("/send/subjectuser/a/{subjectId}/{userId}/{roleId}")
	public String addSubjectMember(@PathParam("subjectId") String subjectId, @PathParam("userId") String userId, @PathParam("roleId") String roleId) {
		if (StringUtil.isEmpty(roleId)) {
			Role role = roleService.findRoleByName(RoleName.READER);
			roleId = role.getId();
		}
		roleService.addRoleUser(subjectId, userId, roleId);
		return new ResponseStatus().toString();
	}

	@Override
	@DELETE
	@Path("/send/subjectuser/d/{subjectId}/{userId}")
	public String deleteSubjectMember(@PathParam("subjectId") String subjectId, @PathParam("userId") String userId) {
		roleService.removeRoleUser(subjectId, userId);
		return new ResponseStatus().toString();
	}

	@Override
	@POST
	@Path("/send/user/u/{userId}")
	public String updatePassword(@PathParam("userId") String userId, @FormParam("oldPassword") String oldPassword, @FormParam("password") String password) {
		ResponseStatus res = null;
		AccountEntity user = accountService.getUser(userId);
		if (user.getPassword().equals(oldPassword)) {
			user.setPassword(password);
			accountService.updateAccount(user);
			res = new ResponseStatus();
			return res.toString();
		} else {
			res = new ResponseStatus(ResponseCode.AUTHORIZE_FAILED);
			return res.toString();
		}

	}

	@Override
	@GET
	@Path("/datetime")
	public long getServerTime() {
		return System.currentTimeMillis();
	}

	@Override
	@POST
	@Path("/send/subject")
	public String addOrUpdateSubject(@FormParam("data") String data) throws IllegalAccessException, InvocationTargetException {
		SubjectEntity subject = (SubjectEntity) JsonUtil.getObject4JsonString(data, SubjectEntity.class);
		SubjectEntity sub = subjectService.getSubject(subject.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		if (sub == null) {
			subject.setCreateUser(user.getId());
			subjectService.addSubject(subject);
		} else {
			sub.setUpdateUser(user.getId());
			sub.setDeleted(Constants.DATA_NOT_DELETED);
			ReflectionUtils.copyBeanProperties(subject, sub);
			subjectService.updateSubject(sub);
		}
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/directory")
	public String addOrUpdateDirectory(@FormParam("data") String data) throws IllegalAccessException, InvocationTargetException {
		DirectoryEntity directory = (DirectoryEntity) JsonUtil.getObject4JsonString(data, DirectoryEntity.class);
		DirectoryEntity dir = directoryService.getDirectory(directory.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		if (dir == null) {
			directory.setCreateUser(user.getId());
			directory.setDeleted(Constants.DATA_NOT_DELETED);
			directoryService.addDirectory(directory);
		} else {
			directory.setUpdateUser(user.getId());
			directory.setDeleted(Constants.DATA_NOT_DELETED);
			ReflectionUtils.copyBeanProperties(directory, dir);
			directoryService.updateDirectory(dir);
		}
		return rs.toString();
	}

	@Override
	@POST
	@Path("/send/note")
	public String addOrUpdateNote(@FormParam("data") String data, @DefaultValue("true") @FormParam("updateContent") boolean updateContent) throws IllegalAccessException, InvocationTargetException {
		NoteEntity note = (NoteEntity) JsonUtil.getObject4JsonString(data, NoteEntity.class);
		NoteEntity n = noteService.getNote(note.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		if (n == null) {
			note.setCreateUser(user.getId());
			note.setDeleted(Constants.DATA_NOT_DELETED);
			noteService.addNote(note);
		} else {
			note.setUpdateUser(user.getId());
			note.setDeleted(Constants.DATA_NOT_DELETED);
			ReflectionUtils.copyBeanProperties(note, n);
			noteService.updateNote(n, updateContent);
		}
		return rs.toString();
	}

	@SuppressWarnings("rawtypes")
	@Override
	@POST
	@Path("/send/tag")
	public String addOrUpdateTag(@FormParam("data") String data) throws IllegalAccessException, InvocationTargetException {
		TagEntity tag = (TagEntity) JsonUtil.getObject4JsonString(data, TagEntity.class);
		TagEntity t = tagService.getTag(tag.getId());
		AccountEntity user = accountService.getUser4Session();
		ResponseStatus rs = new ResponseStatus(ResponseCode.NEXT_RECORD);
		if (t == null) {
			tag.setCreateUser(user.getId());
			tag.setDeleted(Constants.DATA_NOT_DELETED);
			tagService.addTag(tag);
		} else {
			tag.setUpdateUser(user.getId());
			ReflectionUtils.copyBeanProperties(tag, t);
			tagService.updateTag(t);
		}
		return rs.toString();
	}

}
