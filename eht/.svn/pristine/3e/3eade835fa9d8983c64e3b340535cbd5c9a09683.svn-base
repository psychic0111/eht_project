package com.eht.webservice.service.util;

import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.Logger;

import com.eht.common.bean.ResponseStatus;
import com.eht.common.cache.DataCacheTool;
import com.eht.common.constant.Constants;
import com.eht.common.constant.ResponseCode;
import com.eht.common.constant.SynchConstants;
import com.eht.common.util.AppContextUtils;
import com.eht.common.util.FileToolkit;
import com.eht.common.util.JsonUtil;
import com.eht.log.entity.SynchLogEntity;
import com.eht.log.service.SynchLogServiceI;
import com.eht.note.entity.AttachmentEntity;
import com.eht.note.service.AttachmentServiceI;

public class DataSynchizeUtil {
	
	private static Logger logger = Logger.getLogger(DataSynchizeUtil.class);
	
	/**
	 * 服务器附件复制
	 * @param attaServer
	 * @param attachment
	 * @return
	 */
	public static ResponseStatus copyServerFile(AttachmentEntity attaServer, AttachmentEntity attachment){
		ResponseStatus res = new ResponseStatus(); //上传文件操作结果
		try {
			FileToolkit.copyFile(attaServer.getFilePath() + File.separator + attaServer.getFileName(), attachment.getFilePath());
		} catch (IOException e) {
			logger.error("服务器复制文件失败！！！");
			e.printStackTrace();
			res = new ResponseStatus(ResponseCode.SERVER_ERROR);
			e.printStackTrace();
			return res;
		}
		if(!attaServer.getFileName().equals(attachment.getFileName())){
			FileToolkit.renameFile(attachment.getFilePath() + File.separator + attaServer.getFileName(), attachment.getFilePath() + attachment.getFileName());
		}
		
		attachment.setStatus(Constants.FILE_TRANS_COMPLETED);
		attachment.setTranSfer(attaServer.getTranSfer());
		
		return res;
	}
	
	/**
	 * 组织日志格式，返回客户端
	 * @param log
	 * @return
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	public static Map<String, Object> parseLog(SynchLogEntity log){
		Serializable data = null;
		Map<String, Object> map = new HashMap<String, Object>();
		SynchLogServiceI synchLogService = AppContextUtils.getBean("synchLogService");
		if (!log.getAction().equals(SynchConstants.DATA_OPERATE_DELETE) && !log.getClassName().equals(SynchConstants.DATA_CLASS_DIRECTORYBLACK) && !log.getClassName().equals(SynchConstants.DATA_CLASS_NOTEBLACK)
				&& !log.getClassName().equals(SynchConstants.DATA_CLASS_SUBJECTUSER)) {
			Class c = DataCacheTool.getDataClass(log.getClassName());
			data = synchLogService.getEntity(c, log.getClassPK());
			String dataJson = JsonUtil.bean2json(data);
			map = JsonUtil.getMap4Json(dataJson);
		}
		
		map.put("operation", log.getAction());
		map.put("className", log.getClassName());
		map.put("classPK", log.getClassPK());
		map.put("operateTime", log.getOperateTime());
		
		return map;
	}
	
	public static String queryUploadFile(String userId, AttachmentServiceI attachmentService, HttpServletResponse res){
		//准备上传文件
		List<AttachmentEntity> list = attachmentService.findAttachmentByUser(userId, Constants.FILE_TYPE_NORMAL);
		if(list != null && !list.isEmpty()){
			AttachmentEntity attachment = list.get(0);
			
			res.setHeader(SynchConstants.HEADER_NEXT_ACTION, SynchConstants.CLIENT_SYNCH_UPLOAD);
			res.setHeader(SynchConstants.HEADER_NEXT_DATATYPE, SynchConstants.DATA_CLASS_FILE);
			Map<String, String> map = new HashMap<String, String>();
			map.put("attachmentId", attachment.getId());
			map.put("noteUUID", attachment.getNoteId());
			return JsonUtil.map2json(map);
		}else{
			res.setHeader(SynchConstants.HEADER_NEXT_ACTION, SynchConstants.DATA_SYNCH_FINISHED);
			res.setHeader(SynchConstants.HEADER_NEXT_DATATYPE, SynchConstants.DATA_CLASS_FILE);
			return "";
		}
	}
	
	/**
	 * 解析日志action
	 * @param log
	 * @return
	 */
	public static Map<String, Object> convertLog(List<Map<String, Object>> list){
		SynchLogServiceI synchLogService = AppContextUtils.getBean("synchLogService");
		for(Map<String, Object> map : list){
			int value = map.get("val") == null ? 0 : Integer.parseInt(map.get("val").toString());
		}
		
		
		return null;
	}
}
